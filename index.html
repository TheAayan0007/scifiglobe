<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Aayan Globe â€” v1.0</title>
<link href="https://fonts.googleapis.com/css2?family=Rajdhani:wght@400;600;700&family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet"/>
<style>
*,*::before,*::after{box-sizing:border-box;margin:0;padding:0}
:root{
  --bg:#010409; --panel:rgba(5,12,28,0.92); --border:#0d2137;
  --accent:#00ffe7; --accent2:#ff2d6b; --accent3:#ffc300; --dim:#2a4060; --text:#a0c4e0;
}
body{
  background:var(--bg);color:var(--text);
  font-family:'Rajdhani',sans-serif;
  height:100vh;overflow:hidden;
}
body::after{
  content:'';position:fixed;inset:0;
  background:repeating-linear-gradient(0deg,transparent,transparent 3px,rgba(0,255,231,0.008) 3px,rgba(0,255,231,0.008) 4px);
  pointer-events:none;z-index:9999;
}
#c{position:fixed;inset:0;width:100%;height:100%;display:block;}

/* â”€â”€ LOAD SCREEN â”€â”€ */
#loadScreen{
position:fixed;inset:0;z-index:500;
background:var(â€“bg);
display:flex;flex-direction:column;align-items:center;justify-content:center;gap:1.2rem;
}
.load-title{font-family:â€˜Orbitronâ€™,monospace;font-size:.65rem;letter-spacing:.5em;color:var(â€“accent)}
.load-pct{font-family:â€˜Orbitronâ€™,monospace;font-size:2.2rem;font-weight:900;color:var(â€“accent)}
.load-bar-outer{width:320px;height:3px;background:rgba(0,255,231,.08)}
.load-bar-inner{height:100%;width:0%;background:var(â€“accent);transition:width .4s ease;box-shadow:0 0 16px var(â€“accent)}
.load-msg{font-size:.7rem;letter-spacing:.2em;color:var(â€“dim);text-transform:uppercase;font-family:â€˜Rajdhaniâ€™,sans-serif}

/* â”€â”€ HUD â”€â”€ */
#hud{position:fixed;inset:0;pointer-events:none;z-index:20;display:none;}

.hdr{
position:absolute;top:0;left:0;right:0;
padding:.8rem 1.4rem;
display:flex;align-items:center;justify-content:space-between;
background:linear-gradient(180deg,rgba(1,4,9,.95) 0%,transparent 100%);
border-bottom:1px solid rgba(0,255,231,.06);
}
.hdr-name{font-family:â€˜Orbitronâ€™,monospace;font-size:1rem;font-weight:900;color:#fff;letter-spacing:.1em;}
.hdr-name span{color:var(â€“accent)}
.hdr-ver{font-family:â€˜Orbitronâ€™,monospace;font-size:.48rem;letter-spacing:.4em;color:var(â€“accent3);margin-top:.1rem}
.hdr-center{display:flex;align-items:center;gap:.5rem;font-family:â€˜Orbitronâ€™,monospace;font-size:.6rem;letter-spacing:.2em;color:var(â€“accent)}
.live-dot{width:7px;height:7px;border-radius:50%;background:var(â€“accent);box-shadow:0 0 8px var(â€“accent);animation:blink 1.4s ease-in-out infinite}
@keyframes blink{0%,100%{opacity:1}50%{opacity:.3}}
.hdr-time{font-family:â€˜Orbitronâ€™,monospace;font-size:.6rem;color:var(â€“dim);letter-spacing:.15em}

.panel{
position:absolute;z-index:20;background:var(â€“panel);border:1px solid var(â€“border);
padding:.8rem 1rem;backdrop-filter:blur(8px);
}
.panel-title{font-family:â€˜Orbitronâ€™,monospace;font-size:.45rem;letter-spacing:.35em;color:var(â€“dim);text-transform:uppercase;margin-bottom:.7rem;padding-bottom:.4rem;border-bottom:1px solid var(â€“border)}

/* Location panel - bottom left */
#locPanel{
bottom:14px;left:14px;min-width:230px;
clip-path:polygon(0 0,calc(100% - 10px) 0,100% 10px,100% 100%,0 100%);
}
.loc-row{display:flex;justify-content:space-between;align-items:center;margin-bottom:.35rem;font-size:.7rem}
.loc-row:last-child{margin-bottom:0}
.loc-key{color:var(â€“dim);letter-spacing:.05em;font-family:â€˜Rajdhaniâ€™,sans-serif}
.loc-val{font-family:â€˜Orbitronâ€™,monospace;font-size:.6rem;font-weight:700;color:var(â€“accent3);text-align:right;max-width:140px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
.loc-status{display:flex;align-items:center;gap:.4rem;margin-top:.6rem;padding-top:.5rem;border-top:1px solid var(â€“border);font-family:â€˜Orbitronâ€™,monospace;font-size:.5rem;color:var(â€“accent);letter-spacing:.2em}
.loc-status-dot{width:5px;height:5px;border-radius:50%;background:var(â€“accent);animation:blink 1s infinite}
.loc-source-tag{font-family:â€˜Orbitronâ€™,monospace;font-size:.42rem;letter-spacing:.15em;padding:.12rem .3rem;border-radius:2px;margin-left:auto;}
.loc-source-tag.gps{background:rgba(0,255,231,.12);color:var(â€“accent);border:1px solid rgba(0,255,231,.3);}
.loc-source-tag.ip{background:rgba(255,195,0,.1);color:var(â€“accent3);border:1px solid rgba(255,195,0,.3);}

/* Stats panel - bottom right */
#statsPanel{
bottom:14px;right:14px;min-width:150px;
clip-path:polygon(0 0,calc(100% - 10px) 0,100% 10px,100% 100%,0 100%);
}
.stat-row{display:flex;justify-content:space-between;align-items:center;margin-bottom:.35rem;font-size:.7rem}
.stat-row:last-child{margin-bottom:0}
.stat-label{color:var(â€“dim);letter-spacing:.05em;font-family:â€˜Rajdhaniâ€™,sans-serif}
.stat-val{font-family:â€˜Orbitronâ€™,monospace;font-size:.6rem;font-weight:700;color:var(â€“accent)}

/* Controls panel - top right */
#ctrlPanel{top:62px;right:14px;clip-path:polygon(0 0,calc(100% - 10px) 0,100% 10px,100% 100%,0 100%)}
.ctrl-row{display:flex;align-items:center;gap:.5rem;margin-bottom:.3rem;font-size:.65rem;color:var(â€“dim)}
.ctrl-row:last-child{margin-bottom:0}
.ctrl-key{font-family:â€˜Orbitronâ€™,monospace;font-size:.45rem;color:var(â€“accent);border:1px solid var(â€“dim);padding:.1rem .35rem;letter-spacing:.1em}

/* LOD panel - top left */
#lodPanel{top:62px;left:14px;clip-path:polygon(0 0,calc(100% - 10px) 0,100% 10px,100% 100%,0 100%)}
.lod-bar-outer{width:100%;height:2px;background:var(â€“border);margin-top:.3rem;border-radius:1px}
.lod-bar-inner{height:100%;background:var(â€“accent);transition:width .4s ease;border-radius:1px;box-shadow:0 0 6px var(â€“accent)}
#lodLabel{font-family:â€˜Orbitronâ€™,monospace;font-size:.55rem;color:var(â€“accent);letter-spacing:.2em}
#zoomVal{font-family:â€˜Orbitronâ€™,monospace;font-size:1.4rem;font-weight:900;color:var(â€“accent);line-height:1}

/* Corner brackets */
.bracket{position:absolute;z-index:15;width:28px;height:28px;border-color:var(â€“accent);border-style:solid;opacity:.3}
.bracket.tl{top:54px;left:12px;border-width:2px 0 0 2px}
.bracket.tr{top:54px;right:12px;border-width:2px 2px 0 0}
.bracket.bl{bottom:12px;left:12px;border-width:0 0 2px 2px}
.bracket.br{bottom:12px;right:12px;border-width:0 2px 2px 0}

/* Floating location label */
#locationLabel{
position:fixed;pointer-events:none;z-index:30;
transform:translate(-50%,-100%);
opacity:0;transition:opacity .3s;
}
.loc-label-box{
background:rgba(5,12,28,.9);border:1px solid var(â€“accent3);
padding:.4rem .7rem;
clip-path:polygon(0 0,calc(100% - 8px) 0,100% 8px,100% 100%,0 100%);
white-space:nowrap;
}
.loc-label-name{font-family:â€˜Orbitronâ€™,monospace;font-size:.6rem;font-weight:700;color:var(â€“accent3);letter-spacing:.1em}
.loc-label-sub{font-size:.55rem;color:var(â€“dim);letter-spacing:.05em;margin-top:.2rem}
.loc-label-line{
width:1px;height:20px;background:linear-gradient(180deg,var(â€“accent3),transparent);
margin:0 auto;
}

/* â”€â”€ GPS PERMISSION BUTTON â”€â”€ */
#gpsBtn{
position:fixed;
bottom:50%;
left:50%;
transform:translate(-50%,50%);
z-index:100;
pointer-events:all;
display:none;
flex-direction:column;
align-items:center;
gap:.7rem;
background:var(â€“panel);
border:1px solid var(â€“accent);
padding:1.2rem 1.6rem 1.1rem;
clip-path:polygon(0 0,calc(100% - 14px) 0,100% 14px,100% 100%,0 100%);
backdrop-filter:blur(12px);
box-shadow:0 0 40px rgba(0,255,231,.08), 0 0 0 1px rgba(0,255,231,.06) inset;
cursor:pointer;
transition:opacity .4s, transform .4s;
}
#gpsBtn:hover{background:rgba(0,255,231,.06);}
#gpsBtn .btn-icon{font-size:1.6rem;line-height:1;animation:pulse-icon 2s ease-in-out infinite;}
@keyframes pulse-icon{0%,100%{transform:scale(1);filter:drop-shadow(0 0 4px var(â€“accent))}50%{transform:scale(1.12);filter:drop-shadow(0 0 12px var(â€“accent))}}
#gpsBtn .btn-title{font-family:â€˜Orbitronâ€™,monospace;font-size:.62rem;font-weight:700;color:var(â€“accent);letter-spacing:.3em;text-transform:uppercase;}
#gpsBtn .btn-sub{font-size:.6rem;color:var(â€“dim);letter-spacing:.1em;text-align:center;line-height:1.4;}
#gpsBtn .btn-cta{
margin-top:.3rem;
font-family:â€˜Orbitronâ€™,monospace;font-size:.55rem;letter-spacing:.25em;
color:var(â€“bg);background:var(â€“accent);
padding:.35rem .9rem;
clip-path:polygon(0 0,calc(100% - 6px) 0,100% 6px,100% 100%,0 100%);
}
#gpsBtn .btn-skip{font-size:.52rem;color:var(â€“dim);letter-spacing:.1em;text-decoration:underline;cursor:pointer;margin-top:-.2rem;}

/* Floating mini GPS nudge button (bottom center, after HUD shows) */
#gpsMiniBtn{
position:fixed;
bottom:14px;
left:50%;
transform:translateX(-50%);
z-index:100;
pointer-events:all;
display:none;
align-items:center;
gap:.5rem;
background:var(â€“panel);
border:1px solid var(â€“accent3);
padding:.5rem 1rem;
clip-path:polygon(0 0,calc(100% - 8px) 0,100% 8px,100% 100%,0 100%);
backdrop-filter:blur(10px);
cursor:pointer;
font-family:â€˜Orbitronâ€™,monospace;
font-size:.5rem;
color:var(â€“accent3);
letter-spacing:.2em;
transition:opacity .4s;
animation:nudge-glow 2.5s ease-in-out infinite;
}
@keyframes nudge-glow{0%,100%{box-shadow:0 0 8px rgba(255,195,0,.15)}50%{box-shadow:0 0 18px rgba(255,195,0,.35)}}
#gpsMiniBtn .mini-dot{width:6px;height:6px;border-radius:50%;background:var(â€“accent3);animation:blink 1.2s ease-in-out infinite;flex-shrink:0;}
#gpsMiniBtn:hover{background:rgba(255,195,0,.08);}

/* Toast system */
#errorToast{
position:fixed;bottom:80px;right:16px;z-index:200;
display:flex;flex-direction:column-reverse;gap:.4rem;pointer-events:none;
}
.err-card{
background:rgba(5,12,28,.95);border:1px solid var(â€“accent2);
padding:.5rem .75rem;min-width:200px;max-width:280px;
clip-path:polygon(0 0,calc(100% - 8px) 0,100% 8px,100% 100%,0 100%);
font-size:.6rem;
}
.err-card.warn{border-color:var(â€“accent3)}
.err-card.info{border-color:var(â€“accent)}
.err-header{display:flex;justify-content:space-between;margin-bottom:.2rem}
.err-tag{font-family:â€˜Orbitronâ€™,monospace;font-size:.45rem;letter-spacing:.15em;color:var(â€“accent2)}
.err-card.warn .err-tag{color:var(â€“accent3)}
.err-card.info .err-tag{color:var(â€“accent)}
.err-src{font-family:â€˜Orbitronâ€™,monospace;font-size:.42rem;color:var(â€“dim)}
.err-msg{color:var(â€“text);line-height:1.4}
</style>

</head>
<body>

<!-- LOAD SCREEN -->

<div id="loadScreen">
  <div class="load-title">Aayan Systems â€” Globe v1.0</div>
  <div class="load-pct" id="loadPct">0%</div>
  <div class="load-bar-outer"><div class="load-bar-inner" id="loadBar"></div></div>
  <div class="load-msg" id="loadMsg">Initialising renderer...</div>
</div>

<!-- THREE.JS CANVAS -->

<canvas id="c"></canvas>

<!-- GPS PERMISSION MODAL (shown during load if needed) -->

<div id="gpsBtn">
  <div class="btn-icon">ğŸ“¡</div>
  <div class="btn-title">Location Access</div>
  <div class="btn-sub">Grant GPS permission for<br>precise positioning on the globe.</div>
  <div class="btn-cta" id="gpsBtnGrant">GRANT PERMISSION</div>
  <div class="btn-skip" id="gpsBtnSkip">Skip â€” use IP location instead</div>
</div>

<!-- FLOATING MINI NUDGE BUTTON (bottom-center, visible if GPS was denied) -->

<div id="gpsMiniBtn" id="gpsMiniBtn">
  <div class="mini-dot"></div>
  GRANT GPS PERMISSION
</div>

<!-- HUD OVERLAY -->

<div id="hud">
  <div class="hdr">
    <div>
      <div class="hdr-name"><span>Aayan</span> Globe</div>
      <div class="hdr-ver">VERSION 1.0 â€” DOT FIELD ENGINE</div>
    </div>
    <div class="hdr-center"><div class="live-dot"></div>LIVE TRACKING</div>
    <div class="hdr-time" id="clock">--:--:--</div>
  </div>

  <div class="bracket tl"></div><div class="bracket tr"></div>
  <div class="bracket bl"></div><div class="bracket br"></div>

  <!-- LOD panel -->

  <div class="panel" id="lodPanel">
    <div class="panel-title">Render Density</div>
    <div id="zoomVal">--</div>
    <div id="lodLabel">MED</div>
    <div class="lod-bar-outer"><div class="lod-bar-inner" id="lodBar" style="width:50%"></div></div>
  </div>

  <!-- Controls -->

  <div class="panel" id="ctrlPanel">
    <div class="panel-title">Controls</div>
    <div class="ctrl-row"><span class="ctrl-key">DRAG</span>Rotate globe</div>
    <div class="ctrl-row"><span class="ctrl-key">SCROLL</span>Zoom in/out</div>
    <div class="ctrl-row"><span class="ctrl-key">TOUCH</span>Pinch to zoom</div>
  </div>

  <!-- Globe stats -->

  <div class="panel" id="statsPanel">
    <div class="panel-title">Globe Stats</div>
    <div class="stat-row"><span class="stat-label">Dots</span><span class="stat-val" id="dotCount">--</span></div>
    <div class="stat-row"><span class="stat-label">Borders</span><span class="stat-val" id="borderCount">--</span></div>
    <div class="stat-row"><span class="stat-label">Countries</span><span class="stat-val" id="countryCount">--</span></div>
    <div class="stat-row"><span class="stat-label">FPS</span><span class="stat-val" id="fpsVal">--</span></div>
  </div>

  <!-- Location -->

  <div class="panel" id="locPanel">
    <div class="panel-title">Your Location</div>
    <div class="loc-row">
      <span class="loc-key">Source</span>
      <span class="loc-source-tag" id="locSourceTag">--</span>
    </div>
    <div class="loc-row">
      <span class="loc-key">IP</span>
      <span class="loc-val" id="locIP" style="color:var(--accent);font-size:.65rem;letter-spacing:.05em">Scanning...</span>
    </div>
    <div class="loc-row"><span class="loc-key">ISP</span><span class="loc-val" id="locISP">--</span></div>
    <div class="loc-row" style="border-top:1px solid var(--border);padding-top:.35rem;margin-top:.1rem">
      <span class="loc-key">City</span><span class="loc-val" id="locCity">--</span>
    </div>
    <div class="loc-row"><span class="loc-key">Region</span><span class="loc-val" id="locRegion">--</span></div>
    <div class="loc-row"><span class="loc-key">Country</span><span class="loc-val" id="locCountry">--</span></div>
    <div class="loc-row"><span class="loc-key">Lat</span><span class="loc-val" id="locLat">--</span></div>
    <div class="loc-row"><span class="loc-key">Lng</span><span class="loc-val" id="locLng">--</span></div>
    <div class="loc-status"><div class="loc-status-dot"></div>SIGNAL LOCKED</div>
  </div>
</div>

<!-- Error toast container -->

<div id="errorToast"></div>

<!-- Floating 3D label -->

<div id="locationLabel">
  <div class="loc-label-box">
    <div class="loc-label-name" id="locLabelName">--</div>
    <div class="loc-label-sub" id="locLabelSub">--</div>
  </div>
  <div class="loc-label-line"></div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<script src="https://cdn.jsdelivr.net/npm/topojson-client@3/dist/topojson-client.min.js"></script>

<script>
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// AAYAN GLOBE v1.0 â€” GPS + IP Location
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const R   = 200;
let scene, camera, renderer, globeGroup;
let dotMeshes = {};
let currentLOD = 'med';
let borderLines, locationObj;
let isDragging = false, prevMouse = {x:0,y:0};
let rotVel = {x:0, y:0};
let camDist = 580;
let frameTimes = [];

// â”€â”€ Load helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function setLoad(pct, msg){
  document.getElementById('loadBar').style.width = pct+'%';
  document.getElementById('loadPct').textContent = pct+'%';
  document.getElementById('loadMsg').textContent = msg;
}

// â”€â”€ Coordinate converter â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function ll2xyz(lat, lng, r){
  const phi   = (90 - lat) * Math.PI / 180;
  const theta = (lng + 180) * Math.PI / 180;
  return new THREE.Vector3(
    -r * Math.sin(phi) * Math.cos(theta),
     r * Math.cos(phi),
     r * Math.sin(phi) * Math.sin(theta)
  );
}

// â”€â”€ Glow dot texture â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function makeDotTex(){
  const s = 64, c = document.createElement('canvas');
  c.width = c.height = s;
  const ctx = c.getContext('2d');
  const g = ctx.createRadialGradient(s/2,s/2,0,s/2,s/2,s/2);
  g.addColorStop(0,   'rgba(255,255,255,1)');
  g.addColorStop(0.35,'rgba(255,255,255,0.75)');
  g.addColorStop(0.7, 'rgba(255,255,255,0.15)');
  g.addColorStop(1,   'rgba(255,255,255,0)');
  ctx.fillStyle = g;
  ctx.beginPath(); ctx.arc(s/2,s/2,s/2,0,Math.PI*2); ctx.fill();
  return new THREE.CanvasTexture(c);
}

// â”€â”€ Stars â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function makeStars(){
  const n = 4000;
  const pos = new Float32Array(n*3), col = new Float32Array(n*3);
  for(let i=0;i<n;i++){
    const theta = Math.random()*Math.PI*2;
    const phi   = Math.acos(2*Math.random()-1);
    const r     = 1800 + Math.random()*600;
    pos[i*3]   = r*Math.sin(phi)*Math.cos(theta);
    pos[i*3+1] = r*Math.cos(phi);
    pos[i*3+2] = r*Math.sin(phi)*Math.sin(theta);
    const b = 0.3 + Math.random()*0.7;
    col[i*3] = b*0.85; col[i*3+1] = b*0.9; col[i*3+2] = b;
  }
  const geo = new THREE.BufferGeometry();
  geo.setAttribute('position', new THREE.BufferAttribute(pos,3));
  geo.setAttribute('color',    new THREE.BufferAttribute(col,3));
  scene.add(new THREE.Points(geo, new THREE.PointsMaterial({
    size:1.4, vertexColors:true, transparent:true, opacity:0.85
  })));
}

// â”€â”€ Atmosphere â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function makeAtmosphere(){
  [[R*1.04,0x0044cc,0.07],[R*1.12,0x0022aa,0.03],[R*1.25,0x001155,0.015]].forEach(([r,c,o])=>{
    globeGroup.add(new THREE.Mesh(
      new THREE.SphereGeometry(r,64,64),
      new THREE.MeshBasicMaterial({color:c,transparent:true,opacity:o,side:THREE.BackSide})
    ));
  });
}

// â”€â”€ Build dot cloud â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function buildDots(resolution, isLand, tex){
  const landC  = new THREE.Color(0x00ffe7);
  const waterC = new THREE.Color(0x0033bb);
  const pos=[], col=[];
  let count = 0;
  for(let lat=-90;lat<=90;lat+=resolution){
    for(let lng=-180;lng<180;lng+=resolution){
      const land = isLand(lat,lng);
      const v = ll2xyz(lat,lng,R);
      pos.push(v.x,v.y,v.z);
      const c = land ? landC : waterC;
      col.push(c.r,c.g,c.b);
      count++;
    }
  }
  const geo = new THREE.BufferGeometry();
  geo.setAttribute('position', new THREE.BufferAttribute(new Float32Array(pos),3));
  geo.setAttribute('color',    new THREE.BufferAttribute(new Float32Array(col),3));
  const dotSize = {3.0:4.5, 2.0:3.2, 1.2:2.0}[resolution] || 3.2;
  const mat = new THREE.PointsMaterial({
    size: dotSize, map: tex, vertexColors: true,
    transparent: true, opacity: 0.95,
    blending: THREE.AdditiveBlending, depthWrite: false, sizeAttenuation: true,
  });
  return { mesh: new THREE.Points(geo, mat), count };
}

// â”€â”€ Build country borders â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function buildBorders(mesh){
  const pos = [];
  const lines = mesh.type==='MultiLineString' ? mesh.coordinates
              : mesh.type==='LineString'      ? [mesh.coordinates]
              : [];
  let segs = 0;
  for(const line of lines){
    for(let i=0;i<line.length-1;i++){
      const [l1,a1]=line[i], [l2,a2]=line[i+1];
      const p1=ll2xyz(a1,l1,R+0.8), p2=ll2xyz(a2,l2,R+0.8);
      pos.push(p1.x,p1.y,p1.z, p2.x,p2.y,p2.z);
      segs++;
    }
  }
  const geo = new THREE.BufferGeometry();
  geo.setAttribute('position', new THREE.BufferAttribute(new Float32Array(pos),3));
  borderLines = new THREE.LineSegments(geo, new THREE.LineBasicMaterial({
    color:0x00ffe7, transparent:true, opacity:0.32
  }));
  globeGroup.add(borderLines);
  document.getElementById('borderCount').textContent = segs.toLocaleString();
}

// â”€â”€ Location marker â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function buildLocationMarker(lat, lng, city, country){
  // Remove old marker if exists
  if(locationObj){ globeGroup.remove(locationObj.group); }

  const pos = ll2xyz(lat, lng, R+2);
  const group = new THREE.Group();
  const core = new THREE.Mesh(
    new THREE.SphereGeometry(3.5,16,16),
    new THREE.MeshBasicMaterial({color:0xffc300})
  );
  group.add(core);
  const ring1 = new THREE.Mesh(
    new THREE.RingGeometry(5.5,7,48),
    new THREE.MeshBasicMaterial({color:0xffc300,transparent:true,opacity:0.8,side:THREE.DoubleSide})
  );
  const ring2 = new THREE.Mesh(
    new THREE.RingGeometry(10,11.5,48),
    new THREE.MeshBasicMaterial({color:0xffc300,transparent:true,opacity:0.4,side:THREE.DoubleSide})
  );
  group.add(ring1); group.add(ring2);
  const normal = pos.clone().normalize();
  const q = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0,0,1), normal);
  ring1.quaternion.copy(q);
  ring2.quaternion.copy(q);
  group.position.copy(pos);
  globeGroup.add(group);
  locationObj = { group, ring1, ring2, lat, lng, city, country };

  document.getElementById('locCity').textContent    = city    || '--';
  document.getElementById('locCountry').textContent = country || '--';
  document.getElementById('locLat').textContent     = lat.toFixed(4)+'Â°';
  document.getElementById('locLng').textContent     = lng.toFixed(4)+'Â°';
  document.getElementById('locLabelName').textContent = city || 'Your Location';
  document.getElementById('locLabelSub').textContent = `${lat.toFixed(2)}Â° Â· ${lng.toFixed(2)}Â°`;

  // Rotate globe to face location
  globeGroup.rotation.y = -(lng+180)*Math.PI/180+Math.PI;
  globeGroup.rotation.x = -lat*Math.PI/180*0.5;
}

// â”€â”€ Update floating label position â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function updateLabel(){
  if(!locationObj) return;
  const el = document.getElementById('locationLabel');
  const pos3 = locationObj.group.position.clone();
  globeGroup.updateMatrixWorld();
  pos3.applyMatrix4(globeGroup.matrixWorld);
  const invMat = new THREE.Matrix4().copy(globeGroup.matrixWorld).invert();
  const camLocal = camera.position.clone().applyMatrix4(invMat).normalize();
  const markerLocal = locationObj.group.position.clone().normalize();
  const facing = markerLocal.dot(camLocal) > 0.05;
  if(!facing){ el.style.opacity='0'; return; }
  const proj = pos3.clone().project(camera);
  if(proj.z > 1){ el.style.opacity='0'; return; }
  const x = (proj.x*0.5+0.5)*window.innerWidth;
  const y = (-proj.y*0.5+0.5)*window.innerHeight;
  el.style.left  = x+'px';
  el.style.top   = y+'px';
  el.style.opacity = '1';
}

// â”€â”€ LOD switching â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function updateLOD(){
  let target;
  if     (camDist < 360) target='high';
  else if(camDist < 650) target='med';
  else                   target='low';
  if(target!==currentLOD && dotMeshes[target]){
    dotMeshes[currentLOD].visible=false;
    dotMeshes[target].visible=true;
    currentLOD=target;
    document.getElementById('lodLabel').textContent = target.toUpperCase();
    const pct={low:25,med:55,high:90}[target];
    document.getElementById('lodBar').style.width=pct+'%';
    document.getElementById('dotCount').textContent = dotMeshes[target].geometry.attributes.position.count.toLocaleString();
  }
  document.getElementById('zoomVal').textContent = Math.round(camDist);
}

// â”€â”€ Event handlers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function setupEvents(){
  const c = renderer.domElement;
  c.addEventListener('mousedown', e=>{
    isDragging=true; rotVel={x:0,y:0};
    prevMouse={x:e.clientX,y:e.clientY};
  });
  c.addEventListener('mousemove', e=>{
    if(!isDragging) return;
    const dx=e.clientX-prevMouse.x, dy=e.clientY-prevMouse.y;
    globeGroup.rotation.y += dx*0.005;
    globeGroup.rotation.x += dy*0.003;
    globeGroup.rotation.x = Math.max(-Math.PI*0.5, Math.min(Math.PI*0.5, globeGroup.rotation.x));
    rotVel={x:dy*0.003, y:dx*0.005};
    prevMouse={x:e.clientX,y:e.clientY};
  });
  c.addEventListener('mouseup',  ()=>isDragging=false);
  c.addEventListener('mouseleave',()=>isDragging=false);
  c.addEventListener('wheel', e=>{
    e.preventDefault();
    camDist = Math.max(260, Math.min(1100, camDist+e.deltaY*0.4));
    camera.position.z = camDist;
    updateLOD();
  },{passive:false});
  let touchPrev={x:0,y:0};
  let pinchStart=0;
  c.addEventListener('touchstart', e=>{
    if(e.touches.length===1){ isDragging=true; touchPrev={x:e.touches[0].clientX,y:e.touches[0].clientY}; }
    else if(e.touches.length===2){
      const dx=e.touches[0].clientX-e.touches[1].clientX;
      const dy=e.touches[0].clientY-e.touches[1].clientY;
      pinchStart=Math.sqrt(dx*dx+dy*dy);
    }
  });
  c.addEventListener('touchmove', e=>{
    e.preventDefault();
    if(e.touches.length===1 && isDragging){
      const dx=e.touches[0].clientX-touchPrev.x, dy=e.touches[0].clientY-touchPrev.y;
      globeGroup.rotation.y += dx*0.005;
      globeGroup.rotation.x += dy*0.003;
      globeGroup.rotation.x = Math.max(-Math.PI*0.5,Math.min(Math.PI*0.5,globeGroup.rotation.x));
      touchPrev={x:e.touches[0].clientX,y:e.touches[0].clientY};
    } else if(e.touches.length===2){
      const dx=e.touches[0].clientX-e.touches[1].clientX;
      const dy=e.touches[0].clientY-e.touches[1].clientY;
      const dist=Math.sqrt(dx*dx+dy*dy);
      camDist = Math.max(260,Math.min(1100, camDist-(dist-pinchStart)*0.5));
      camera.position.z=camDist;
      pinchStart=dist;
      updateLOD();
    }
  },{passive:false});
  c.addEventListener('touchend',()=>isDragging=false);
  window.addEventListener('resize',()=>{
    camera.aspect=window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth,window.innerHeight);
  });
}

// â”€â”€ Clock â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function updateClock(){
  const d=new Date();
  document.getElementById('clock').textContent =
    d.getHours().toString().padStart(2,'0')+':'+
    d.getMinutes().toString().padStart(2,'0')+':'+
    d.getSeconds().toString().padStart(2,'0');
}

// â”€â”€ FPS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function calcFPS(){
  const now=performance.now();
  frameTimes.push(now);
  frameTimes=frameTimes.filter(t=>now-t<1000);
  return frameTimes.length;
}

// â”€â”€ Render loop â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function animate(){
  requestAnimationFrame(animate);
  if(!isDragging){
    globeGroup.rotation.y += 0.0008;
    rotVel.x*=0.93; rotVel.y*=0.93;
    if(Math.abs(rotVel.y)>0.00005) globeGroup.rotation.y+=rotVel.y;
    if(Math.abs(rotVel.x)>0.00005) globeGroup.rotation.x+=rotVel.x;
    globeGroup.rotation.x=Math.max(-Math.PI*0.5,Math.min(Math.PI*0.5,globeGroup.rotation.x));
  }
  if(locationObj){
    const t=Date.now()*0.0025;
    const s1=1+0.45*Math.sin(t);
    const s2=1+0.3*Math.sin(t*0.7+1);
    locationObj.ring1.scale.set(s1,s1,1);
    locationObj.ring2.scale.set(s2,s2,1);
    locationObj.ring1.material.opacity=0.5+0.35*Math.abs(Math.sin(t));
    locationObj.ring2.material.opacity=0.2+0.2*Math.abs(Math.sin(t*0.7));
  }
  updateLabel();
  updateClock();
  document.getElementById('fpsVal').textContent=calcFPS();
  renderer.render(scene,camera);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TOAST SYSTEM
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let toastTimers = [];

function showToast(type, tag, msg, autoDismissMs=0){
  const container = document.getElementById('errorToast');
  if(!container) return;
  const card = document.createElement('div');
  card.className = 'err-card'+(type==='warn'?' warn':type==='info'?' info':'');
  const time = new Date().toLocaleTimeString();
  card.innerHTML =
    '<div class="err-header">'+
      '<span class="err-tag">'+tag+'</span>'+
      '<span class="err-src">'+time+'</span>'+
    '</div>'+
    '<div class="err-msg">'+msg+'</div>';
  container.appendChild(card);
  if(autoDismissMs>0){
    const t=setTimeout(()=>{
      card.style.opacity='0';card.style.transition='opacity .4s';
      setTimeout(()=>card.remove(),400);
    },autoDismissMs);
    toastTimers.push(t);
  }
  return card;
}

function clearToasts(){
  toastTimers.forEach(clearTimeout); toastTimers=[];
  const c=document.getElementById('errorToast');
  if(!c) return;
  [...c.children].forEach(el=>{
    el.style.opacity='0';el.style.transition='opacity .3s';
    setTimeout(()=>el.remove(),300);
  });
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// GPS / GEOLOCATION LOGIC
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Returns {lat, lng} from GPS or rejects
function getGPSLocation(){
  return new Promise((resolve, reject)=>{
    if(!navigator.geolocation){
      reject(new Error('Geolocation API not supported'));
      return;
    }
    navigator.geolocation.getCurrentPosition(
      pos => resolve({ lat: pos.coords.latitude, lng: pos.coords.longitude }),
      err => reject(err),
      { enableHighAccuracy: true, timeout: 12000, maximumAge: 0 }
    );
  });
}

// Reverse geocode GPS coords using a free API
async function reverseGeocode(lat, lng){
  try{
    const r = await fetch(
      `https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lng}&zoom=10`,
      { headers: { 'Accept-Language': 'en' } }
    );
    const d = await r.json();
    const a = d.address || {};
    return {
      city:    a.city || a.town || a.village || a.county || '',
      region:  a.state || a.region || '',
      country: a.country || '',
    };
  }catch(e){
    return { city:'', region:'', country:'' };
  }
}

// IP-based geolocation (multi-API fallback)
async function getIPLocation(){
  const IP_APIS = [
    {
      url:'https://ipwho.is/',
      parse: d => ({
        ip:d.ip, isp:d.connection?.isp||d.org||'',
        city:d.city, region:d.region, country:d.country,
        lat:parseFloat(d.latitude), lng:parseFloat(d.longitude),
        ok: !d.message && d.success!==false
      })
    },
    {
      url:'https://ip-api.com/json/?fields=status,message,country,regionName,city,lat,lon,isp,org,query',
      parse: d => ({
        ip:d.query, isp:d.org||d.isp||'',
        city:d.city, region:d.regionName, country:d.country,
        lat:parseFloat(d.lat), lng:parseFloat(d.lon),
        ok: d.status==='success'
      })
    },
    {
      url:'https://ipapi.co/json/',
      parse: d => ({
        ip:d.ip, isp:d.org||d.isp||'',
        city:d.city, region:d.region, country:d.country_name||d.country,
        lat:parseFloat(d.latitude), lng:parseFloat(d.longitude),
        ok: !d.error
      })
    },
    {
      url:'https://freeipapi.com/api/json',
      parse: d => ({
        ip:d.ipAddress, isp:d.isp||'',
        city:d.cityName, region:d.regionName, country:d.countryName,
        lat:parseFloat(d.latitude), lng:parseFloat(d.longitude),
        ok: !!d.ipAddress
      })
    },
  ];

  for(const api of IP_APIS){
    try{
      const hostname = new URL(api.url).hostname;
      showToast('info','TRYING '+hostname,'Attempting IP geolocation...', 2000);
      const r = await Promise.race([
        fetch(api.url),
        new Promise((_,rej)=>setTimeout(()=>rej(new Error('Timeout 5s')),5000))
      ]);
      if(!r.ok) throw new Error('HTTP '+r.status);
      const raw = await r.json();
      const d   = api.parse(raw);
      if(!d.ok) throw new Error('API failure status');
      if(!d.lat||!d.lng) throw new Error('No coordinates');
      clearToasts();
      return d;
    }catch(err){
      const host = new URL(api.url).hostname;
      showToast('warn','FAIL: '+host, err.message||String(err), 3000);
      await new Promise(r=>setTimeout(r,300));
    }
  }
  throw new Error('All IP APIs failed');
}

// Show/hide mini GPS button
function showMiniGpsBtn(onGrant){
  const btn = document.getElementById('gpsMiniBtn');
  btn.style.display = 'flex';
  btn.onclick = async ()=>{
    btn.style.opacity = '0.4';
    btn.style.pointerEvents = 'none';
    try{
      const coords = await getGPSLocation();
      hideMiniGpsBtn();
      onGrant(coords);
    }catch(e){
      btn.style.opacity = '1';
      btn.style.pointerEvents = 'all';
      showToast('warn','GPS DENIED', e.message || 'Permission denied', 3500);
    }
  };
}

function hideMiniGpsBtn(){
  const btn = document.getElementById('gpsMiniBtn');
  btn.style.transition = 'opacity .4s';
  btn.style.opacity = '0';
  setTimeout(()=>{ btn.style.display='none'; btn.style.opacity='1'; }, 400);
}

// Check cached permission state (if available)
async function checkPermissionState(){
  try{
    const status = await navigator.permissions.query({ name: 'geolocation' });
    return status.state; // 'granted' | 'denied' | 'prompt'
  }catch(e){
    return 'prompt';
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MAIN INIT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function main(){
  // Scene setup
  scene = new THREE.Scene();
  camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 1, 5000);
  camera.position.z = camDist;
  renderer = new THREE.WebGLRenderer({canvas:document.getElementById('c'), antialias:true, alpha:true});
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setClearColor(0x010409, 1);

  globeGroup = new THREE.Group();
  scene.add(globeGroup);

  makeStars();
  makeAtmosphere();
  setupEvents();
  animate();

  setLoad(10,'Fetching world topology...');
  let topo;
  try{
    topo = await fetch('https://cdn.jsdelivr.net/npm/world-atlas@2/countries-110m.json').then(r=>r.json());
  }catch(e){
    setLoad(10,'CDN failed: '+e.message); return;
  }

  setLoad(30,'Drawing land mask...');
  const land      = topojson.feature(topo, topo.objects.land);
  const countries = topojson.feature(topo, topo.objects.countries);
  const borders   = topojson.mesh(topo, topo.objects.countries);
  document.getElementById('countryCount').textContent = countries.features.length;

  // Land mask
  const MW=2048, MH=1024;
  const mc = document.createElement('canvas');
  mc.width=MW; mc.height=MH;
  const mctx = mc.getContext('2d');
  mctx.fillStyle='#000'; mctx.fillRect(0,0,MW,MH);
  mctx.fillStyle='#fff';
  function drawGeomToMask(geom){
    const {type,coordinates}=geom;
    function drawRing(ring){
      if(!ring||ring.length<3) return;
      mctx.beginPath();
      mctx.moveTo((ring[0][0]+180)/360*MW, (90-ring[0][1])/180*MH);
      for(let i=1;i<ring.length;i++) mctx.lineTo((ring[i][0]+180)/360*MW,(90-ring[i][1])/180*MH);
      mctx.closePath(); mctx.fill();
    }
    if(type==='Polygon') drawRing(coordinates[0]);
    else if(type==='MultiPolygon') coordinates.forEach(p=>drawRing(p[0]));
    else if(type==='GeometryCollection') geom.geometries.forEach(drawGeomToMask);
  }
  if(land.type==='Feature') drawGeomToMask(land.geometry);
  else if(land.type==='FeatureCollection') land.features.forEach(f=>drawGeomToMask(f.geometry));
  const imgData = mctx.getImageData(0,0,MW,MH).data;
  function isLand(lat,lng){
    const x=Math.max(0,Math.min(MW-1,Math.floor(((lng+180)%360)/360*MW)));
    const y=Math.max(0,Math.min(MH-1,Math.floor((90-lat)/180*MH)));
    return imgData[(y*MW+x)*4]>128;
  }

  setLoad(50,'Generating dot field LODs...');
  const tex = makeDotTex();
  const lodConfigs = [{key:'low',res:3.0},{key:'med',res:2.0},{key:'high',res:1.2}];
  for(const {key,res} of lodConfigs){
    const {mesh,count} = buildDots(res, isLand, tex);
    dotMeshes[key] = mesh;
    mesh.visible = (key===currentLOD);
    globeGroup.add(mesh);
    if(key===currentLOD) document.getElementById('dotCount').textContent=count.toLocaleString();
  }

  setLoad(75,'Building country borders...');
  buildBorders(borders);

  // â”€â”€ LOCATION RESOLUTION â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  setLoad(88,'Resolving your position...');

  const permState = await checkPermissionState();

  // Helper: apply GPS data to globe
  async function applyGPS(coords){
    showToast('info','GPS ACQUIRED',`Lat ${coords.lat.toFixed(4)} Â· Lng ${coords.lng.toFixed(4)}`, 3000);
    setLoad(94,'Reverse geocoding...');
    const geo = await reverseGeocode(coords.lat, coords.lng);
    document.getElementById('locIP').textContent     = 'GPS';
    document.getElementById('locISP').textContent    = 'Device GPS';
    document.getElementById('locRegion').textContent = geo.region  || '--';

    const tag = document.getElementById('locSourceTag');
    tag.textContent = 'GPS'; tag.className='loc-source-tag gps';

    buildLocationMarker(coords.lat, coords.lng,
      geo.city || 'GPS Location',
      geo.country || '');
    document.getElementById('locLabelSub').textContent =
      `GPS Â· ${coords.lat.toFixed(2)}Â° ${coords.lng.toFixed(2)}Â°`;
    clearToasts();
    showToast('info','LOCK ACQUIRED â€” GPS', `${geo.city||''}, ${geo.country||''}`, 4000);
  }

  // Helper: apply IP data to globe
  async function applyIP(data){
    const {ip,isp,city,region,country,lat,lng} = data;
    document.getElementById('locIP').textContent     = ip      || '--';
    document.getElementById('locISP').textContent    = (isp||'').length>24 ? isp.slice(0,24)+'â€¦' : (isp||'--');
    document.getElementById('locRegion').textContent = region  || '--';

    const tag = document.getElementById('locSourceTag');
    tag.textContent = 'IP'; tag.className='loc-source-tag ip';

    buildLocationMarker(lat, lng, city||'Unknown', country||'Unknown');
    document.getElementById('locLabelSub').textContent =
      `IP Â· ${lat.toFixed(2)}Â° ${lng.toFixed(2)}Â°`;
    clearToasts();
    showToast('info','LOCK ACQUIRED â€” IP', `${ip} Â· ${city}, ${country}`, 4000);
  }

  if(permState === 'granted'){
    // Already have permission â€” get GPS silently
    try{
      const coords = await getGPSLocation();
      await applyGPS(coords);
    }catch(e){
      showToast('warn','GPS FALLBACK', 'Falling back to IP geolocation', 2500);
      try{ await applyIP(await getIPLocation()); }
      catch(e2){ buildLocationMarker(20.59, 85.09, 'Default Location', 'IN'); }
    }

  } else if(permState === 'denied'){
    // Already denied â€” go straight to IP, show mini button
    showToast('warn','GPS DENIED','Using IP location. Grant permission to improve accuracy.', 4000);
    try{ await applyIP(await getIPLocation()); }
    catch(e){ buildLocationMarker(20.59, 85.09, 'Default Location', 'IN'); }

    // Show HUD then mini button
    setLoad(100,'Ready!');
    await new Promise(r=>setTimeout(r,400));
    document.getElementById('loadScreen').style.display='none';
    document.getElementById('hud').style.display='block';
    updateLOD();

    showMiniGpsBtn(async (coords)=>{
      await applyGPS(coords);
    });
    return; // exit early (HUD already shown)

  } else {
    // 'prompt' â€” show our custom modal first
    await new Promise(resolve=>{
      const modal = document.getElementById('gpsBtn');
      modal.style.display = 'flex';

      document.getElementById('gpsBtnGrant').onclick = async ()=>{
        modal.style.opacity='0.5';
        modal.style.pointerEvents='none';
        try{
          const coords = await getGPSLocation();
          modal.style.display='none';
          resolve({ type:'gps', coords });
        }catch(e){
          showToast('warn','GPS DENIED', e.message||'Permission denied', 3000);
          modal.style.display='none';
          resolve({ type:'denied' });
        }
      };

      document.getElementById('gpsBtnSkip').onclick = ()=>{
        modal.style.display='none';
        resolve({ type:'skip' });
      };
    }).then(async result=>{
      if(result.type === 'gps'){
        await applyGPS(result.coords);
      } else {
        // denied or skip â†’ IP fallback
        if(result.type === 'denied'){
          showToast('warn','GPS DENIED','Falling back to IP geolocation', 2500);
        }
        try{ await applyIP(await getIPLocation()); }
        catch(e){ buildLocationMarker(20.59, 85.09, 'Default Location', 'IN'); }

        // Show mini re-grant button (only if denied, not skip)
        if(result.type === 'denied'){
          // Schedule after HUD shows
          setTimeout(()=>{
            showMiniGpsBtn(async (coords)=>{
              await applyGPS(coords);
            });
          }, 800);
        }
      }
    });
  }

  setLoad(100,'Ready!');
  await new Promise(r=>setTimeout(r,400));
  document.getElementById('loadScreen').style.display='none';
  document.getElementById('hud').style.display='block';
  updateLOD();
}

main().catch(e=>{ document.getElementById('loadMsg').textContent='Error: '+e.message; });
</script>

</body>
</html>